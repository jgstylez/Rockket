// Export Service for Rockket Platform
// Handles exporting business plans, roadmaps, and mission data

import { Mission } from './storage';

export type ExportFormat = 'json' | 'markdown' | 'pdf' | 'csv';

export interface ExportOptions {
    format: ExportFormat;
    includeMetadata?: boolean;
    sections?: string[];
}

class ExportService {
    /**
     * Export mission data in various formats
     */
    exportMission(mission: Mission, options: ExportOptions): void {
        switch (options.format) {
            case 'json':
                this.exportAsJSON(mission, options);
                break;
            case 'markdown':
                this.exportAsMarkdown(mission, options);
                break;
            case 'csv':
                this.exportAsCSV(mission, options);
                break;
            case 'pdf':
                // PDF export would require a library like jsPDF
                console.warn('PDF export not yet implemented');
                this.exportAsMarkdown(mission, options); // Fallback to markdown
                break;
            default:
                throw new Error(`Unsupported format: ${options.format}`);
        }
    }

    /**
     * Export as JSON
     */
    private exportAsJSON(mission: Mission, options: ExportOptions): void {
        const data = options.includeMetadata
            ? mission
            : { ...mission, id: undefined, createdAt: undefined, updatedAt: undefined };

        const jsonString = JSON.stringify(data, null, 2);
        const filename = `${this.sanitizeFilename(mission.name)}_mission.json`;

        this.downloadFile(jsonString, filename, 'application/json');
    }

    /**
     * Export as Markdown
     */
    private exportAsMarkdown(mission: Mission, options: ExportOptions): void {
        let markdown = '';

        // Header
        markdown += `# ${mission.name}\n\n`;
        markdown += `**Industry:** ${mission.industry}  \n`;
        markdown += `**Stage:** ${this.formatStage(mission.stage)}  \n`;

        if (options.includeMetadata) {
            markdown += `**Created:** ${new Date(mission.createdAt).toLocaleDateString()}  \n`;
            markdown += `**Last Updated:** ${new Date(mission.updatedAt).toLocaleDateString()}  \n`;
        }

        markdown += `\n---\n\n`;

        // Genesis Pad Section
        markdown += `## ðŸ” Genesis Pad - Market Validation\n\n`;
        markdown += `**Signal Strength:** ${mission.data.signalStrength}%\n\n`;

        if (mission.data.mvpData) {
            markdown += `### MVP Definition\n\n`;
            markdown += `${JSON.stringify(mission.data.mvpData, null, 2)}\n\n`;
        }

        // Ignition Pad Section
        markdown += `## ðŸš€ Ignition Pad - Business Setup\n\n`;

        if (mission.data.setupTasks.length > 0) {
            markdown += `### Setup Tasks\n\n`;

            const tasksByCategory = this.groupTasksByCategory(mission.data.setupTasks);

            Object.entries(tasksByCategory).forEach(([category, tasks]) => {
                markdown += `#### ${this.formatCategory(category)}\n\n`;
                tasks.forEach((task: any) => {
                    const checkbox = task.status === 'complete' ? '[x]' : '[ ]';
                    markdown += `- ${checkbox} **${task.name}** - ${task.description}\n`;
                });
                markdown += `\n`;
            });
        }

        if (mission.data.brandIdentity) {
            markdown += `### Brand Identity\n\n`;
            markdown += `${JSON.stringify(mission.data.brandIdentity, null, 2)}\n\n`;
        }

        // Velocity Pad Section
        markdown += `## ðŸ“ˆ Velocity Pad - Growth & Optimization\n\n`;

        if (mission.data.metrics.length > 0) {
            markdown += `### Key Metrics\n\n`;
            markdown += `| Metric | Value |\n`;
            markdown += `|--------|-------|\n`;
            mission.data.metrics.forEach((metric: any) => {
                markdown += `| ${metric.name} | ${metric.value} |\n`;
            });
            markdown += `\n`;
        }

        if (mission.data.trajectories.length > 0) {
            markdown += `### Active Trajectories\n\n`;
            mission.data.trajectories.forEach((traj: any) => {
                markdown += `- **${traj.name}** (${traj.type}): ${traj.description}\n`;
            });
            markdown += `\n`;
        }

        if (mission.data.goals.length > 0) {
            markdown += `### Optimization Goals\n\n`;
            mission.data.goals.forEach((goal: any) => {
                markdown += `- **${goal.name}**: ${goal.metric} â†’ ${goal.targetValue}\n`;
            });
            markdown += `\n`;
        }

        // Footer
        markdown += `\n---\n\n`;
        markdown += `*Generated by Rockket Platform on ${new Date().toLocaleDateString()}*\n`;

        const filename = `${this.sanitizeFilename(mission.name)}_business_plan.md`;
        this.downloadFile(markdown, filename, 'text/markdown');
    }

    /**
     * Export as CSV (for metrics and tasks)
     */
    private exportAsCSV(mission: Mission, options: ExportOptions): void {
        let csv = '';

        // Setup Tasks CSV
        csv += `Setup Tasks\n`;
        csv += `Category,Task,Description,Status,Progress\n`;

        mission.data.setupTasks.forEach((task: any) => {
            csv += `"${task.category}","${task.name}","${task.description}","${task.status}",${task.progress}\n`;
        });

        csv += `\n\nMetrics\n`;
        csv += `Name,Value\n`;

        mission.data.metrics.forEach((metric: any) => {
            csv += `"${metric.name}",${metric.value}\n`;
        });

        const filename = `${this.sanitizeFilename(mission.name)}_data.csv`;
        this.downloadFile(csv, filename, 'text/csv');
    }

    /**
     * Export business roadmap
     */
    exportRoadmap(mission: Mission): void {
        let markdown = '';

        markdown += `# ${mission.name} - Business Roadmap\n\n`;
        markdown += `## Mission Overview\n\n`;
        markdown += `- **Industry:** ${mission.industry}\n`;
        markdown += `- **Current Stage:** ${this.formatStage(mission.stage)}\n`;
        markdown += `- **Launch Pad:** ${mission.data.selectedLaunchPad || 'Not selected'}\n\n`;

        markdown += `## Phase 1: Genesis (Market Validation)\n\n`;
        markdown += `- [ ] Complete market research\n`;
        markdown += `- [ ] Validate problem-solution fit\n`;
        markdown += `- [ ] Define MVP scope\n`;
        markdown += `- [ ] Achieve ${mission.data.signalStrength}% signal strength\n\n`;

        markdown += `## Phase 2: Ignition (Business Setup)\n\n`;
        const tasksByCategory = this.groupTasksByCategory(mission.data.setupTasks);
        Object.entries(tasksByCategory).forEach(([category, tasks]) => {
            markdown += `### ${this.formatCategory(category)}\n`;
            tasks.forEach((task: any) => {
                const checkbox = task.status === 'complete' ? '[x]' : '[ ]';
                markdown += `- ${checkbox} ${task.name}\n`;
            });
            markdown += `\n`;
        });

        markdown += `## Phase 3: Velocity (Growth)\n\n`;
        mission.data.goals.forEach((goal: any) => {
            markdown += `- [ ] ${goal.name}: Reach ${goal.targetValue} ${goal.metric}\n`;
        });

        markdown += `\n---\n\n`;
        markdown += `*Roadmap generated on ${new Date().toLocaleDateString()}*\n`;

        const filename = `${this.sanitizeFilename(mission.name)}_roadmap.md`;
        this.downloadFile(markdown, filename, 'text/markdown');
    }

    /**
     * Helper: Download file
     */
    private downloadFile(content: string, filename: string, mimeType: string): void {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');

        link.href = url;
        link.download = filename;
        link.click();

        URL.revokeObjectURL(url);
        console.log(`âœ… Downloaded: ${filename}`);
    }

    /**
     * Helper: Sanitize filename
     */
    private sanitizeFilename(name: string): string {
        return name
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '_')
            .replace(/^_+|_+$/g, '');
    }

    /**
     * Helper: Format stage name
     */
    private formatStage(stage: string): string {
        const stages: Record<string, string> = {
            ideation: 'Genesis (Ideation)',
            setup: 'Ignition (Setup)',
            growth: 'Velocity (Growth)',
        };
        return stages[stage] || stage;
    }

    /**
     * Helper: Format category name
     */
    private formatCategory(category: string): string {
        return category.charAt(0).toUpperCase() + category.slice(1);
    }

    /**
     * Helper: Group tasks by category
     */
    private groupTasksByCategory(tasks: any[]): Record<string, any[]> {
        return tasks.reduce((acc, task) => {
            const category = task.category || 'other';
            if (!acc[category]) {
                acc[category] = [];
            }
            acc[category].push(task);
            return acc;
        }, {} as Record<string, any[]>);
    }
}

// Export singleton instance
export const exportService = new ExportService();
